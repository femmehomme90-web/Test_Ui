local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local joueur = Players.LocalPlayer
local MonNomDePlot = joueur:GetAttribute("InPlot") -- recup√©rer le plot du joueur
local MonPlot = workspace.CoreObjects.Plots:FindFirstChild(MonNomDePlot) --transformation en format utilisable
local Bank = joueur.leaderstats.Cash:GetAttribute("ExactValue") --r√©cup√©rer le cash du joueur et c'est un forma chiffres   
local ClientUtils = require(ReplicatedStorage:WaitForChild("Client"):WaitForChild("Modules"):WaitForChild("ClientUtils")) --avec ca on r√©cupere pleins de choses importantes 
local rebirths = (ClientUtils.ProfileData and ClientUtils.ProfileData.leaderstats and ClientUtils.ProfileData.leaderstats.Rebirths) or 0
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Networker = ReplicatedStorage.Shared.Packages.Networker

local RaretesRecherchees = {
    "GOD",
    "Event",
    "Divine",
    "Admin",
    "Exclusive",
}

local function GetConvoyeurInfo()
    wait(0.2)
    local EggFolder = workspace.CoreObjects.Eggs
    for _, model in ipairs(EggFolder:GetChildren()) do
        if model:GetAttribute("CurrentEgg") then
            -- R√©cup√®re le premier (et unique) enfant, quel que soit son nom
            local meshPart = model:GetChildren()[1]
            
            if meshPart and meshPart:IsA("MeshPart") then
                local billboard = meshPart:FindFirstChild("BillboardAttachment")
                if billboard then
                    local eggBillboard = billboard:FindFirstChild("EggBillboard")
                    if eggBillboard then
                        local EggFrame = eggBillboard:FindFirstChild("Frame")
                        if EggFrame then 
                            local Rarity = EggFrame:FindFirstChild("Rarity")
                            if Rarity and Rarity:IsA("TextLabel") then
                                return Rarity.Text, model.Name
                            end
                        end
                    end
                end
            end
        end
    end
    return nil, nil
end

local function EstRareteRecherchee(rarete)
    for _, rareteRecherchee in ipairs(RaretesRecherchees) do
        if rarete == rareteRecherchee then
            return true
        end
    end
    return false
end

-- Nouvelle fonction pour retry complet (brainrotName ET raret√©)
local function TrouverOeufCompletAvecRetry(maxTentatives)
    maxTentatives = maxTentatives or 5 -- Par d√©faut 5 tentatives
    
    for tentative = 1, maxTentatives do
        local rarityText, brainrotName = GetConvoyeurInfo()
        
        -- Si on a TOUT trouv√©, on retourne
        if rarityText and brainrotName then 
            print("‚úÖ ≈íuf trouv√© (tentative " .. tentative .. "/" .. maxTentatives .. "):", brainrotName, "-", rarityText)
            return rarityText, brainrotName
        end
        
        -- Logs de debug pour savoir ce qui manque
        --if brainrotName and not rarityText then
        --elseif not brainrotName then
       --end
        
        -- Attendre avant le prochain essai (sauf √† la derni√®re tentative)
        if tentative < maxTentatives then
            wait(0.3) 
        end
    end
    
    warn("‚ùå Impossible de trouver l'≈ìuf complet apr√®s", maxTentatives, "tentatives")
    return nil, nil
end

local function AutoBuyEgg()
    while true do
        wait(0.3) 
        
        -- Premi√®re tentative rapide
        local rarityText, brainrotName = GetConvoyeurInfo()
        
        -- Si on n'a pas trouv√© l'≈ìuf OU la raret√©, on fait des retry
        if not brainrotName or not rarityText then
            warn("üîÑ Retry n√©cessaire - brainrotName:", brainrotName, "| raret√©:", rarityText)
            rarityText, brainrotName = TrouverOeufCompletAvecRetry(5)
        end
        
        -- Maintenant on v√©rifie si on a TOUT
        if brainrotName and rarityText then
            -- On a trouv√© l'≈ìuf ET sa raret√©
            if EstRareteRecherchee(rarityText) then
                print("üíé ACHAT:", brainrotName, "-", rarityText, "| Cash:", Bank)
                Networker["RF/BuyEgg"]:InvokeServer(brainrotName, 1)
                Networker["RF/BuyEgg"]:InvokeServer(brainrotName, 1)
                Networker["RF/BuyEgg"]:InvokeServer(brainrotName, 1)
                print("‚úÖ Achat termin√© | Cash:", Bank)
                Networker["RF/RequestEggSpawn"]:InvokeServer()
                wait(0.2)
            else     
                Networker["RF/RequestEggSpawn"]:InvokeServer()
            end
        else
            -- M√™me apr√®s retry, on n'a pas r√©ussi √† trouver l'≈ìuf
            warn("‚ùå √âchec total de d√©tection - Skip vers le prochain ≈ìuf")
            Networker["RF/RequestEggSpawn"]:InvokeServer()
        end
    end
end

AutoBuyEgg()
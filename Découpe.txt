locals : 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer.Backpack

local Networker = ReplicatedStorage.Shared.Packages.Networker
local PlaceEggRF = Networker["RF/PlaceEgg"]

r√©cup√©rer le rebirth
--------------------------------
local function getRebirths()
    local ClientUtils = require(ReplicatedStorage.Client.Modules.ClientUtils)
    local ProfileData = ClientUtils.ProfileData

    if ProfileData and ProfileData.leaderstats and ProfileData.leaderstats.Rebirths then
        return ProfileData.leaderstats.Rebirths
    end

    warn("Impossible de r√©cup√©rer les Rebirths")
    return 0
end

local rebirths = getRebirths()

r√©cup√©rer le plot du joueur 
--------------------------------
local function getMyPlot()
    local Plots = workspace.CoreObjects.Plots

    for _, p in ipairs(Plots:GetChildren()) do
        local o, ov = p:GetAttribute("Owner"), p:FindFirstChild("Owner")
        if o == LocalPlayer.Name or o == LocalPlayer.UserId
        or (ov and (ov.Value == LocalPlayer.Name or ov.Value == LocalPlayer.UserId)) then
            return p
        end
    end

    warn("No plot")
end

local myPlot = getMyPlot()
if not myPlot then return end

r√©cup√©rer mes stands 
----------------------------------
local function getStandsFolder(plot)
    local stands = plot:FindFirstChild("Stands")
    if not stands then
        warn("No stands")
    end
    return stands
end

local standsFolder = getStandsFolder(myPlot)
if not standsFolder then return end

Trouver un ≈ìuf dans l‚Äôinventaire
-----------------------------------
local function findEggTool()
    for _, tool in ipairs(Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local attrs = tool:GetAttributes()
            if attrs and attrs.Egg == true then
                return tool
            end
        end
    end
end

√âquiper un tool
------------------------------
local function equipTool(tool)
    if tool and LocalPlayer.Character then
        tool.Parent = LocalPlayer.Character
        task.wait(0.15)
    end
end

V√©rifier nom du stand (Stand1 ‚Üí Stand50)
--------------------------------------------
local function isValidStandName(stand)
    local number = stand.Name:match("^Stand(%d+)$")
    number = tonumber(number)
    return number and number <= 50
end

V√©rifier acc√®s au stand (Rebirth)
---------------------------------------
ocal function canUseStand(stand, rebirths)
    local requirement = stand:GetAttribute("Requirement")
    return requirement == nil or (type(requirement) == "number" and requirement <= rebirths)
end

V√©rifier si le stand est vide
-------------------------------------
local function isStandEmpty(stand)
    if stand:FindFirstChildOfClass("Model") then
        return false
    end

    for _, d in ipairs(stand:GetDescendants()) do
        if d:IsA("TextLabel") and d.Name == "Timer" then
            return false
        end
    end

    return true
end

Trouver un stand valide
---------------------------------
local function findEmptyUsableStand(standsFolder, rebirths)
    for _, stand in ipairs(standsFolder:GetChildren()) do
        if isValidStandName(stand)
        and canUseStand(stand, rebirths)
        and isStandEmpty(stand) then
            return stand
        end
    end
end



Placer un oeuf 
--------------------------------------------
local function placeEgg()
    local eggTool = findEggTool()
    if not eggTool then
        warn("Aucun oeuf dans l'inventaire")
        return
    end

    local stand = findEmptyUsableStand(standsFolder, rebirths)
    if not stand then
        warn("Aucun stand valide (‚â§50), accessible et vide")
        return
    end

    equipTool(eggTool)

    PlaceEggRF:InvokeServer(
        stand.Name,
        eggTool.Name
    )

    print(" Oeuf plac√© :", eggTool.Name, "‚Üí", stand.Name)
end



Avoir l'etat du stand 
---------------------------
local function getStandState(stand)
    -- Brainrot pr√©sent
    if stand:FindFirstChildOfClass("Model") then
        return "Brainrot"
    end

    -- Egg pr√©sent (timer visible)
    for _, d in ipairs(stand:GetDescendants()) do
        if d:IsA("TextLabel") and d.Name == "Timer" then
            return "Egg"
        end
    end

    -- Sinon vide
    return "Empty"
end

Avoir les infos sur le stand 
-------------------------------

local function readStandContent(stand)
    local state = getStandState(stand)

    local data = {
        State = state,
        Name = nil,
        Rarity = nil,
        GainPerSec = nil,
        Timer = nil
    }

    -- Brainrot
    if state == "Brainrot" then
        local brainrot = stand:FindFirstChildOfClass("Model")
        local bb = brainrot
            and brainrot:FindFirstChild("HumanoidRootPart")
            and brainrot.HumanoidRootPart:FindFirstChild("BrainrotBillboard")

        if brainrot then
            data.Name = brainrot.Name
        end

        if bb then
            data.Rarity = bb.Rarity.Text
            data.GainPerSec = bb.Multiplier.Text
        end
    end

    -- Egg
    if state == "Egg" then
        for _, d in ipairs(stand:GetDescendants()) do
            if d:IsA("TextLabel") and d.Name == "Timer" then
                data.Timer = d.Text
                break
            end
        end
    end

    return data
end


info sur l'oeuf dans le convoyeur
--------------------------------------------------------
local function scanEggs(eggsFolder)
    local results = {}

    for _, egg in ipairs(eggsFolder:GetChildren()) do
        local info = {
            EggModel = egg,
            Name = "Pas d‚Äô≈ìuf",
            Price = "N/A",
            Rarity = "N/A"
        }

        local targetMesh = nil
        -- Cherche le mesh qui contient BillboardAttachment
        for _, child in ipairs(egg:GetChildren()) do
            if child:FindFirstChild("BillboardAttachment") then
                targetMesh = child
                break
            end
        end

        if targetMesh then
            local billboardAttachment = targetMesh:FindFirstChild("BillboardAttachment")
            local eggBillboard = billboardAttachment and billboardAttachment:FindFirstChild("EggBillboard")
            local frame = eggBillboard and eggBillboard:FindFirstChild("Frame")

            if frame then
                -- TextLabels
                local priceLabel = frame:FindFirstChild("Price")
                local nameLabel = frame:FindFirstChild("EggName")
                local rarityLabel = frame:FindFirstChild("Rarity")

                info.Name = (nameLabel and nameLabel:IsA("TextLabel") and nameLabel.Text) or "Pas d‚Äô≈ìuf"
                info.Price = (priceLabel and priceLabel:IsA("TextLabel") and priceLabel.Text) or "N/A"
                info.Rarity = (rarityLabel and rarityLabel:IsA("TextLabel") and rarityLabel.Text) or "N/A"
            end
        end

        table.insert(results, info)
    end

    return results
end

acheter l'oeuf sur le convoyeur. 
---------------------------------------------------------------------
local function getEggsOnConveyor(eggsFolder)
    local results = {}

    for _, egg in ipairs(eggsFolder:GetChildren()) do
        local eggName = "Pas d‚Äô≈ìuf"

        -- Cherche le mesh qui contient BillboardAttachment
        local targetMesh = nil
        for _, child in ipairs(egg:GetChildren()) do
            if child:FindFirstChild("BillboardAttachment") then
                targetMesh = child
                break
            end
        end

        if targetMesh then
            local billboardAttachment = targetMesh:FindFirstChild("BillboardAttachment")
            local eggBillboard = billboardAttachment and billboardAttachment:FindFirstChild("EggBillboard")
            local frame = eggBillboard and eggBillboard:FindFirstChild("Frame")

            if frame and frame:FindFirstChild("EggName") and frame.EggName:IsA("TextLabel") then
                eggName = frame.EggName.Text or "Pas d‚Äô≈ìuf"
            end
        end

        table.insert(results, {
            EggModel = egg,
            EggName = eggName
        })
    end

    return results
end

changer l'oeuf sur le convoyeur
------------------------------------------
game:GetService("ReplicatedStorage")
	.Shared.Packages.Networker["RF/RequestEggSpawn"]
	:InvokeServer()

ouvrir un oeuf 
-----------------------------------------------
game:GetService("ReplicatedStorage").Shared.Packages.Networker["RE/HatchEgg"]:FireServer("Stand10","nom du brainrot sur le stand")

Rammasser la boite et vendre la box 
------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")

local PickupBoxesRE =
    ReplicatedStorage.Shared.Packages.Networker["RE/PickupBoxes"]

local function pickupAndSellBox()
    -- 1Ô∏è‚É£ Ramasser la bo√Æte
    PickupBoxesRE:FireServer()
    print("üì¶ Bo√Æte ramass√©e")

    task.wait(0.3)

    -- 2Ô∏è‚É£ Appuyer sur E
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

Upgrade un brainrot 
-----------------------------------------------------------
game:GetService("ReplicatedStorage").Shared.Packages.Networker["RF/UpgradeBrainrot"]:InvokeServer("Stand1")

r√©cuperer un brainrot sur un stand
-------------------------------------------------------------
game:GetService("ReplicatedStorage").Shared.Packages.Networker["RE/PickupBrainrot"]:FireServer("Stand9")